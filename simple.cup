/**********************************************************************
 Java CUP specification for a parser for Simple programs
 **********************************************************************/

import java_cup.runtime.*;

parser code {:

public void syntax_error(Symbol currToken) {
    Errors.fatal(((TokenVal)currToken.value).linenum,
	         ((TokenVal)currToken.value).charnum,
		 "Syntax error");
}

:};


/* Terminals (tokens returned by the scanner) */
terminal TokenVal       PUBLIC;
terminal TokenVal       CLASS;
terminal TokenVal       STATIC;
terminal TokenVal       INT;
terminal TokenVal       BOOLEAN;
terminal TokenVal       STRING;
terminal TokenVal       VOID;
terminal TokenVal       TRUE;
terminal TokenVal       FALSE;
terminal TokenVal       IF;
terminal TokenVal       ELSE;
terminal TokenVal       WHILE;
terminal TokenVal 	    DO;
terminal TokenVal       PRINT;
terminal TokenVal       RETURN;
terminal IdIdent        ID;
terminal IntLitTokenVal INTLITERAL;
terminal StringIdent    STRINGLITERAL;
terminal TokenVal       LCURLY;
terminal TokenVal       RCURLY;
terminal TokenVal       LPAREN;
terminal TokenVal       RPAREN;
terminal TokenVal       COMMA;
terminal TokenVal       ASSIGN;
terminal TokenVal       SEMICOLON;
terminal TokenVal       PLUS;
terminal TokenVal       MINUS;
terminal TokenVal       TIMES;
terminal TokenVal       DIVIDE;
terminal TokenVal       NOT;
terminal TokenVal       AND;
terminal TokenVal       OR;
terminal TokenVal       EQUALS;
terminal TokenVal       NOTEQUALS;
terminal TokenVal       LESS;
terminal TokenVal       GREATER;
terminal TokenVal       LESSEQ;
terminal TokenVal       GREATEREQ;

terminal UMINUS;
/* Non-terminals
 *
 * NOTE: You will need to add more nonterminals to this list as you
 *       add productions to the grammar below.
 */
non terminal ProgramNode      program;
non terminal ClassBodyNode    classBody;
non terminal MethodDeclNode   methodDecl;
non terminal MethodBodyNode   methodBody;

non terminal DeclListNode     varDeclList;
non terminal Sequence         stmtList;
non terminal ExpListNode      actualList;
non terminal Sequence         declList;


non terminal DeclNode	      decl;
non terminal FieldDeclNode    fieldDecl;
non terminal VarDeclNode      varDecl;
non terminal TypeNode	      type;
non terminal IdNode	          id;
non terminal ExpNode          expr;
non terminal StmtNode         stmt;
non terminal FormalDeclNode   formalDecl;




precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;
precedence left UMINUS;
start with program;

/*
 * grammar with actions
 *
 * add more here
 */
program		::= PUBLIC CLASS id:i LCURLY classBody:c RCURLY
            {: RESULT = new ProgramNode(i, c);:}
            ;

classBody	::= declList:d
            {: RESULT = new ClassBodyNode(new DeclListNode(d));:}
            ;


declList 	::= declList:dl decl:d
		     {:
		     dl.addToEnd(d);
		     RESULT = dl;
		    :}
		    | /* epsilon */
		    {: RESULT = new Sequence();:}
		    ;

decl	    ::= fieldDecl:v
            {: RESULT = v;:}
            | varDecl:v
            {: RESULT = v;:}
            ;

fieldDecl	::= STATIC type:t id:i SEMICOLON
		    {: RESULT = new FieldDeclNode(t, i);:}
		    ;



formalDecl  ::= type:t id:i
            {:RESULT = new FormalDeclNode(t,i);:}
            ;

methodBody  ::= LCURLY varDeclList:v stmtList:s RCURLY
            {:RESULT = new MethodBodyNode(v,new StmtListNode(s));:}
            ;

varDeclList ::= varDeclList varDecl
            //TODO Add proper function
            |
            /* Epsilon */
            ;

varDecl     ::= type:t id:i SEMICOLON
            {: RESULT = new VarDeclNode(t, i);:}
            ;

stmtList    ::= stmtList:sl stmt:s
            {:
            sl.addToEnd(s);
            RESULT = sl;
            :}
            |
            {:RESULT = new Sequence();:}
            /* Epsilon */
            ;

stmt        ::= PRINT LPAREN expr:e RPAREN SEMICOLON
            {:RESULT = new PrintStmtNode(e);:}
            |
            id:i ASSIGN expr:e SEMICOLON
            {:RESULT = new AssignStmtNode(i,e);:}
            |
            IF LPAREN expr:e RPAREN LCURLY stmtList:s RCURLY
            {:RESULT = new IfStmtNode(e, new StmtListNode(s));:}
            |
            IF LPAREN expr:e RPAREN LCURLY stmtList:s RCURLY ELSE LCURLY stmtList:se RCURLY
            {:RESULT = new IfElseStmtNode(e, new StmtListNode(s), new StmtListNode(se));:}
            |
            DO LCURLY stmtList:s RCURLY WHILE LPAREN expr:e RPAREN
            {:RESULT = new WhileStmtNode(e, new StmtListNode(s));:}
            |
            RETURN SEMICOLON
            {:RESULT = new ReturnStmtNode();:}
            |
            RETURN expr SEMICOLON
            {:RESULT = new ReturnStmtNode();:}
            |
            id:i LPAREN RPAREN SEMICOLON
            {:RESULT = new CallStmtNode(i);:}
            |
            id:i LPAREN actualList:e RPAREN SEMICOLON
            {:RESULT = new CallStmtNode(i,e);:}
            |
            LCURLY varDeclList stmtList RCURLY
            //TODO Add proper function
            ;

expr ::=
            expr:e PLUS expr:e2
            {:RESULT = new PlusNode(e,e2);:}
            |
            expr:e MINUS expr:e2
            {:RESULT = new MinusNode(e,e2);:}
            |
            expr:e TIMES expr:e2
            {:RESULT = new TimesNode(e,e2);:}
            |
            expr:e DIVIDE expr:e2
            {:RESULT = new DivideNode(e,e2);:}
            |
            expr:e NOT
            {:RESULT = new NotNode(e);:}
            |
            expr:e AND expr:e2
            {:RESULT = new AndNode(e,e2);:}
            |
            expr:e OR expr:e2
            {:RESULT = new OrNode(e,e2);:}
            |
            expr:e EQUALS expr:e2
            {:RESULT = new EqualsNode(e,e2);:}
            |
            expr:e NOTEQUALS expr:e2
            {:RESULT = new NotEqualsNode(e,e2);:}
            |
            expr:e LESS expr:e2
            {:RESULT = new LessNode(e,e2);:}
            |
            expr:e GREATER expr:e2
            {:RESULT = new GreaterNode(e,e2);:}
            |
            expr:e LESSEQ expr:e2
            {:RESULT = new LessEqNode(e,e2);:}
            |
            expr:e GREATEREQ expr:e2
            {:RESULT = new GreaterEqNode(e,e2);:}
            |
            //TODO: Add POWER operator in simple.lex
            MINUS expr:e
            {:RESULT = new UnaryMinusNode(e);:}
            %prec UMINUS
            |
            id:i
            {:RESULT = i;:}
            |
            INTLITERAL:i
            {: RESULT = new IntLitNode(i.linenum, i.charnum, i.intVal);:}
            |
            STRINGLITERAL:i
            {: RESULT = new StringLitNode(i.linenum, i.charnum, i.strIdent);:}
            |
            TRUE:i
            {: RESULT = new TrueNode(i.linenum, i.charnum);:}
            |
            FALSE:i
            {: RESULT = new FalseNode(i.linenum, i.charnum);:}
            |
            LPAREN expr:e RPAREN
            {:RESULT = e;:}
            |
            id LPAREN RPAREN SEMICOLON
            //TODO Add proper fucntion
            |
            id LPAREN actualList RPAREN SEMICOLON
            //TODO Add proper function
            ;

actualList  ::= expr:e
            |
            actualList COMMA expr:e
            // TODO Add proper fucntion
            ;

type        ::= INT
            {: RESULT = new IntNode(); :}
            |
            BOOLEAN
            {: RESULT = new BooleanNode();:}
            |
            STRING
            {: RESULT = new StringNode();:}
            ;

id          ::= ID:i
            {: RESULT = new IdNode(i.linenum, i.charnum, i.idVal);:}
            ;
